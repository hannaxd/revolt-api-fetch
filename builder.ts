import openapi from "openapi-typescript";

const notice =
  `// This file was auto-generated by @rawrxd/revolt-api - do not edit manually\n`;

Deno.readTextFile("openapi.json").then(async (openapiFile) => {
  let data = openapiFile;
  Deno.mkdirSync("out/", { recursive: true });
  Deno.copyFile("base/mod.ts", "out/mod.ts");

  // do the replace patch if needed
  if (Deno.env.get("REWRITE_ANYOF")) {
    data = data.replace(/"anyOf"/g, '"oneOf"');
  }

  // toJSON
  const spec = JSON.parse(data);

  openapi(spec, { commentHeader: notice }).then((data) => {
    Deno.writeTextFile(
      "out/schema.ts",
      data.replace("T extends any", "T extends unknown"),
    );
  });

  {
    const entries = [
      "import type { paths } from './schema.ts';",
      "export type APIRoutes =",
    ];
    const paths = Object.keys(spec.paths);
    const queryData: Record<string, unknown[]> = {};

    for (const path of paths) {
      const data = spec.paths[path];
      const methods = Object.keys(data);

      const template = path.replace(/\{\w+\}/g, "${string}");

      for (const method of methods) {
        const operation = `paths['${path}']['${method}']`;

        const route = data[method];
        const routeResponse = Object.keys(route["responses"]).find((x) =>
          x !== "default"
        ) || "default";
        const content_type =
          Object.keys(route["responses"][routeResponse]["content"] || {})[0];
        const response = routeResponse === "204" || !content_type
          ? "undefined"
          : `${operation}['responses']['${routeResponse}']['content']['${content_type}']`;

        const queryParams = [];
        let hasBody = false;

        if (route["parameters"]) {
          for (const parameter of route["parameters"]) {
            if (parameter.in === "query") {
              queryParams.push(parameter.name);
            }
          }
        }

        if (route["requestBody"]?.["content"]?.["application/json"]) {
          hasBody = true;
        }

        let params = "undefined";
        if (hasBody || queryParams.length > 0) {
          const entries = [];

          if (queryParams.length > 0) {
            entries.push(`${operation}['parameters']['query']`);
          }

          if (hasBody) {
            entries.push(
              `${operation}['requestBody']['content']['application/json']`,
            );
          }

          params = entries.join("|");
        }

        const parts = path.split("").filter((x) => x === "/").length;
        entries.push(
          `| { method: '${method}', path: \`${template}\`, parts: ${parts}, params: ${params}, response: ${response} }`,
        );

        if (/\{\w+\}/.test(path)) {
          entries.push(
            `| { method: '${method}', path: '-${path}', parts: ${parts}, params: ${params}, response: ${response} }`,
          );
        }

        queryData[path] = {
          ...queryData[path],
          [method]: queryParams,
        };
      }
    }

    // deno-lint-ignore no-explicit-any
    const pathResolve = {} as Record<number, any>;
    for (const path of paths) {
      const segments = path.split("/");
      segments.shift();
      pathResolve[segments.length] = [
        ...(pathResolve[segments.length] || []),
        segments.map((key) => /\{.*\}/.test(key) ? [key] : key),
      ];
    }

    Deno.writeTextFile("out/routes.ts", notice + entries.join("\n") + ";");
    Deno.writeTextFile(
      "out/params.ts",
      notice + "export const pathResolve = " + JSON.stringify(pathResolve) +
        ";\n" + "export const queryParams = " + JSON.stringify(queryData) + ";",
    );
  }

  let toGen = JSON.parse(openapiFile);
  await generateTypes(toGen);

  const baseURL = spec["servers"]?.[0]?.["url"];
  Deno.writeTextFile(
    "out/baseURL.ts",
    notice +
      `export const defaultBaseURL = ${
        baseURL ? '"' + baseURL + '"' : "undefined"
      };`,
  );
});



//  _    _       _         _    _            _          ______                
// | |  | |     | |       | |  | |          | |        |___  /                
// | |  | | __ _| |_   _  | |__| | __ _  ___| | _____     / / ___  _ __   ___ 
// | |  | |/ _` | | | | | |  __  |/ _` |/ __| |/ / __|   / / / _ \| '_ \ / _ \
// | |__| | (_| | | |_| | | |  | | (_| | (__|   <\__ \  / /_| (_) | | | |  __/
// \____/ \__, |_|\__, | |_|  |_|\__,_|\___|_|\_\___/ /_____\___/|_| |_|\___|
//         __/ |   __/ |                                                     
//        |___/   |___/                                                      



async function generateTypes(spec: any) {
  try {
    if (!spec.components || !spec.components.schemas) {
      return;
    }

    const schemas = spec.components.schemas;
    const entries = [];

    for (const [schemaName, schema] of Object.entries(schemas)) {
      const typeDefinition = generateTypeDefinition(schemaName, schema);
      entries.push(typeDefinition);
    }

    let output = entries.join("\n") + ";";
    output = output.replace(
      /export type (\w+)/g,
      (match, typeName) => `export type ${typeName.replace(/\s+/g, "_")}`,
    );
    // Fix recursive references
    output = output.replace(/components\["schemas"\]\["([^"]+)"\]/g, "$1");
    // Fix types with spaces in their names
    output = output.replace(/Authifier Error/g, "Authifier_Error");
    output = output.replace(/ISO8601 Timestamp/g, "ISO8601_Timestamp");

    await Deno.writeTextFile("out/types.ts", output);
  } catch (error) {
    console.error("Error processing spec:", error);
  }
}

function generateTypeDefinition(schemaName: string, schema: any): string {
  if (schema.anyOf || schema.oneOf) {
    const types = (schema.anyOf || schema.oneOf).map((subSchema: any) => formatSchema(subSchema));
    const unionType = types.join(" | ");
    return `export type ${schemaName} = ${unionType};`;
  } else if (schema.allOf) {
    const types = schema.allOf.map((subSchema: any) => formatSchema(subSchema));
    const intersectionType = types.join(" & ");
    return `export type ${schemaName} = ${intersectionType};`;
  } else if (schema.type === "object") {
    if (schema.properties || schema.additionalProperties) {
      const properties = formatObjectProperties(schema);
      return `export type ${schemaName} = {\n${properties}\n};`;
    } else {
      // Object with no defined properties
      return `export type ${schemaName} = { [key: string]: unknown };`;
    }
  } else if (schema.$ref) {
    const refKey = schema.$ref.split("/").pop();
    return `export type ${schemaName} = components["schemas"]["${refKey}"];`;
  } else {
    const tsType = formatSchema(schema);
    return `export type ${schemaName} = ${tsType};`;
  }
}

function formatSchema(schema: any): string {
  if (schema.$ref) {
    const refKey = schema.$ref.split("/").pop();
    return `components["schemas"]["${refKey}"]`;
  } else if (schema.anyOf || schema.oneOf) {
    const types = (schema.anyOf || schema.oneOf).map((subSchema: any) => formatSchema(subSchema));
    let tsType = types.join(" | ");
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (schema.allOf) {
    const types = schema.allOf.map((subSchema: any) => formatSchema(subSchema));
    let tsType = types.join(" & ");
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (schema.type === "object") {
    if (schema.properties || schema.additionalProperties) {
      const properties = formatObjectProperties(schema);
      let tsType = `{\n${properties}\n}`;
      if (schema.nullable) {
        tsType += " | null";
      }
      return tsType;
    } else {
      return `{ [key: string]: unknown }`;
    }
  } else if (schema.type === "array") {
    const itemType = schema.items ? formatSchema(schema.items) : "unknown";
    let tsType = `${itemType}[]`;
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (schema.enum) {
    const enumValues = schema.enum.map((value: any) => JSON.stringify(value)).join(" | ");
    let tsType = enumValues;
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else {
    let tsType = mapPrimitiveType(schema.type);
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  }
}

function formatObjectProperties(schema: any): string {
  const requiredProperties = schema.required || [];
  const properties: string[] = [];

  if (schema.properties) {
    properties.push(
      ...Object.entries(schema.properties).map(([key, prop]) => {
        const isRequired = requiredProperties.includes(key);
        return formatProperty(key, prop, isRequired);
      })
    );
  }

  if (schema.additionalProperties) {
    const valueType = formatSchema(schema.additionalProperties);
    properties.push(`  [key: string]: ${valueType};`);
  }

  return properties.join("\n");
}

function formatProperty(key: string, prop: any, isRequired: boolean): string {
  const optionalMark = isRequired ? "" : "?";
  const tsType = formatSchema(prop);
  return `  ${key}${optionalMark}: ${tsType};`;
}

function mapPrimitiveType(type: string): string {
  switch (type) {
    case "string":
      return "string";
    case "number":
    case "integer":
      return "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    default:
      return "unknown";
  }
}
