import openapi from "openapi-typescript";

const notice =
  `// This file was auto-generated by @rawrxd/revolt-api - do not edit manually\n`;

Deno.readTextFile("openapi.json").then(async (data) => {
  Deno.mkdirSync("out", { recursive: true });
  Deno.copyFile("base/mod.ts", "out/mod.ts");

  // do the replace patch if needed
  if (Deno.env.get("REWRITE_ANYOF")) {
    data = data.replace(/"anyOf"/g, '"oneOf"');
  }

  // toJSON
  const spec = JSON.parse(data);

  openapi(spec, { commentHeader: notice }).then((data) => {
    Deno.writeTextFile(
      "out/schema.ts",
      data.replace("T extends any", "T extends unknown"),
    );
  });

  {
    const entries = [
      "import type { paths } from './schema.ts';",
      "export type APIRoutes =",
    ];
    const paths = Object.keys(spec.paths);
    const queryData: Record<string, unknown[]> = {};

    for (const path of paths) {
      const data = spec.paths[path];
      const methods = Object.keys(data);

      const template = path.replace(/\{\w+\}/g, "${string}");

      for (const method of methods) {
        const operation = `paths['${path}']['${method}']`;

        const route = data[method];
        const routeResponse = Object.keys(route["responses"]).find((x) =>
          x !== "default"
        ) || "default";
        const content_type =
          Object.keys(route["responses"][routeResponse]["content"] || {})[0];
        const response = routeResponse === "204" || !content_type
          ? "undefined"
          : `${operation}['responses']['${routeResponse}']['content']['${content_type}']`;

        const queryParams = [];
        let hasBody = false;

        if (route["parameters"]) {
          for (const parameter of route["parameters"]) {
            if (parameter.in === "query") {
              queryParams.push(parameter.name);
            }
          }
        }

        if (route["requestBody"]?.["content"]?.["application/json"]) {
          hasBody = true;
        }

        let params = "undefined";
        if (hasBody || queryParams.length > 0) {
          const entries = [];

          if (queryParams.length > 0) {
            entries.push(`${operation}['parameters']['query']`);
          }

          if (hasBody) {
            entries.push(
              `${operation}['requestBody']['content']['application/json']`,
            );
          }

          params = entries.join("|");
        }

        const parts = path.split("").filter((x) => x === "/").length;
        entries.push(
          `| { method: '${method}', path: \`${template}\`, parts: ${parts}, params: ${params}, response: ${response} }`,
        );

        if (/\{\w+\}/.test(path)) {
          entries.push(
            `| { method: '${method}', path: '-${path}', parts: ${parts}, params: ${params}, response: ${response} }`,
          );
        }

        queryData[path] = {
          ...queryData[path],
          [method]: queryParams,
        };
      }
    }

    // deno-lint-ignore no-explicit-any
    const pathResolve = {} as Record<number, any>;
    for (const path of paths) {
      const segments = path.split("/");
      segments.shift();
      pathResolve[segments.length] = [
        ...(pathResolve[segments.length] || []),
        segments.map((key) => /\{.*\}/.test(key) ? [key] : key),
      ];
    }

    Deno.writeTextFile("out/routes.ts", notice + entries.join("\n") + ";");
    Deno.writeTextFile(
      "out/params.ts",
      notice + "export const pathResolve = " + JSON.stringify(pathResolve) +
        ";\n" + "export const queryParams = " + JSON.stringify(queryData) + ";",
    );
  }

  await generateTypes(spec);

  const baseURL = spec["servers"]?.[0]?.["url"];
  Deno.writeTextFile(
    "out/baseURL.ts",
    notice +
      `export const defaultBaseURL = ${
        baseURL ? '"' + baseURL + '"' : "undefined"
      };`,
  );
});



//  _    _       _         _    _            _          ______                
// | |  | |     | |       | |  | |          | |        |___  /                
// | |  | | __ _| |_   _  | |__| | __ _  ___| | _____     / / ___  _ __   ___ 
// | |  | |/ _` | | | | | |  __  |/ _` |/ __| |/ / __|   / / / _ \| '_ \ / _ \
// | |__| | (_| | | |_| | | |  | | (_| | (__|   <\__ \  / /_| (_) | | | |  __/
// \____/ \__, |_|\__, | |_|  |_|\__,_|\___|_|\_\___/ /_____\___/|_| |_|\___|
//         __/ |   __/ |                                                     
//        |___/   |___/                                                      



async function generateTypes(spec: any) {
  try {
    if (!spec.components || !spec.components.schemas) {
      return;
    }

    const schemas = spec.components.schemas;
    const entries = [];

    for (const [schemaName, schema] of Object.entries(schemas)) {
      const typeDefinition = generateTypeDefinition(schemaName, schema);
      entries.push(typeDefinition);
    }

    let output = entries.join("\n") + ";";
    output = output.replace(
      /export type (\w+)/g,
      (match, typeName) => `export type ${typeName.replace(/\s+/g, "_")}`,
    );
    // all types generate correctly but recursive references aren't, this ugly hack just changes the recursive reference fuckup to the type 
    output = output.replace(/components\["schemas"\]\["([^"]+)"\]/g, "$1");
    // Fix the two types that have FUCKING SPACES in them
    output = output.replace(/Authifier Error/g, "Authifier_Error");
    output = output.replace(/ISO8601 Timestamp/g, "ISO8601_Timestamp");

    await Deno.writeTextFile("out/types.ts", output);
  } catch (error) {
    console.error("Error processing spec:", error);
  }
}

function generateTypeDefinition(schemaName: string, schema: any): string {
  if (schema.type === "object" && schema.properties) {
    const properties = Object.entries(schema.properties)
      .map(([key, prop]) => formatProperty(key, prop))
      .join("\n");
    return `export type ${schemaName} = {\n${properties}\n};`;
  }
  return `export type ${schemaName} = ${mapPrimitiveType(schema.type)};`;
}

function formatProperty(key: string, prop: any): string {
  if (prop.$ref) {
    const refKey = prop.$ref.split("/").pop();
    return `  ${key}: components["schemas"]["${refKey}"];`;
  }

  if (prop.allOf) {
    const types = prop.allOf.map((subSchema: any) => {
      if (subSchema.$ref) {
        const refKey = subSchema.$ref.split("/").pop();
        return `components["schemas"]["${refKey}"]`;
      }
      return mapPrimitiveType(subSchema.type);
    }).join(" & ");
    return `  ${key}: ${types};`;
  }

  if (prop.type === "array") {
    const itemType = prop.items ? formatItemType(prop.items) : "unknown[]";
    return `  ${key}: ${itemType};`;
  }

  if (prop.type === "object" && prop.properties) {
    const nestedProps = Object.entries(prop.properties)
      .map(([nestedKey, nestedProp]) => formatProperty(nestedKey, nestedProp))
      .join("\n");
    return `  ${key}: {\n${nestedProps}\n};`;
  }

  return `  ${key}: ${mapPrimitiveType(prop.type)};`;
}

function formatItemType(item: any): string {
  if (item.$ref) {
    const refKey = item.$ref.split("/").pop();
    return `components["schemas"]["${refKey}"][]`;
  }
  if (item.allOf) {
    const types = item.allOf.map((subSchema: any) => {
      if (subSchema.$ref) {
        const refKey = subSchema.$ref.split("/").pop();
        return `components["schemas"]["${refKey}"]`;
      }
      return mapPrimitiveType(subSchema.type);
    }).join(" & ");
    return `${types}[]`;
  }
  if (item.type === "object" && item.properties) {
    const nestedProps = Object.entries(item.properties)
      .map(([nestedKey, nestedProp]) => formatProperty(nestedKey, nestedProp))
      .join("\n");
    return `{\n${nestedProps}\n}[]`;
  }

  return mapPrimitiveType(item.type);
}

function mapPrimitiveType(type: string): string {
  switch (type) {
    case "string":
      return "string";
    case "number":
      return "number";
    case "boolean":
      return "boolean";
    case "integer":
      return "number";
    case "null":
      return "null";
    default:
      return "unknown";
  }
}