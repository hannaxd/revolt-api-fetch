// deno-lint-ignore-file no-explicit-any

import openapi from "openapi-typescript";

const notice =
  `// This file was auto-generated by @rawrxd/revolt-api - do not edit manually\n`;

Deno.readTextFile("openapi.json").then(async (openapiFile) => {
  let data = openapiFile;
  Deno.mkdirSync("out/", { recursive: true });
  Deno.copyFile("base/mod.ts", "out/mod.ts");

  // do the replace patch if needed
  if (Deno.env.get("REWRITE_ANYOF")) {
    data = data.replace(/"anyOf"/g, '"oneOf"');
  }

  // toJSON
  const spec = JSON.parse(data);

  openapi(spec, { commentHeader: notice }).then((data) => {
    Deno.writeTextFile(
      "out/schema.ts",
      data.replace("T extends any", "T extends unknown"),
    );
  });

  {
    const entries = [
      "import type { paths } from './schema.ts';",
      "export type APIRoutes =",
    ];
    const paths = Object.keys(spec.paths);
    const queryData: Record<string, unknown[]> = {};

    for (const path of paths) {
      const data = spec.paths[path];
      const methods = Object.keys(data);

      const template = path.replace(/\{\w+\}/g, "${string}");

      for (const method of methods) {
        const operation = `paths['${path}']['${method}']`;

        const route = data[method];
        const routeResponse = Object.keys(route["responses"]).find((x) =>
          x !== "default"
        ) || "default";
        const content_type =
          Object.keys(route["responses"][routeResponse]["content"] || {})[0];
        const response = routeResponse === "204" || !content_type
          ? "undefined"
          : `${operation}['responses']['${routeResponse}']['content']['${content_type}']`;

        const queryParams = [];
        let hasBody = false;

        if (route["parameters"]) {
          for (const parameter of route["parameters"]) {
            if (parameter.in === "query") {
              queryParams.push(parameter.name);
            }
          }
        }

        if (route["requestBody"]?.["content"]?.["application/json"]) {
          hasBody = true;
        }

        let params = "undefined";
        if (hasBody || queryParams.length > 0) {
          const entries = [];

          if (queryParams.length > 0) {
            entries.push(`${operation}['parameters']['query']`);
          }

          if (hasBody) {
            entries.push(
              `${operation}['requestBody']['content']['application/json']`,
            );
          }

          params = entries.join("|");
        }

        const parts = path.split("").filter((x) => x === "/").length;
        entries.push(
          `| { method: '${method}', path: \`${template}\`, parts: ${parts}, params: ${params}, response: ${response} }`,
        );

        if (/\{\w+\}/.test(path)) {
          entries.push(
            `| { method: '${method}', path: '-${path}', parts: ${parts}, params: ${params}, response: ${response} }`,
          );
        }

        queryData[path] = {
          ...queryData[path],
          [method]: queryParams,
        };
      }
    }

    const pathResolve = {} as Record<number, any>;
    for (const path of paths) {
      const segments = path.split("/");
      segments.shift();
      pathResolve[segments.length] = [
        ...(pathResolve[segments.length] || []),
        segments.map((key) => /\{.*\}/.test(key) ? [key] : key),
      ];
    }

    Deno.writeTextFile("out/routes.ts", notice + entries.join("\n") + ";");
    Deno.writeTextFile(
      "out/params.ts",
      notice + "export const pathResolve = " + JSON.stringify(pathResolve) +
        ";\n" + "export const queryParams = " + JSON.stringify(queryData) + ";",
    );
  }

  const toGen = JSON.parse(openapiFile);
  await generateTypes(toGen);

  const baseURL = spec["servers"]?.[0]?.["url"];
  Deno.writeTextFile(
    "out/baseURL.ts",
    notice +
      `export const defaultBaseURL = ${
        baseURL ? '"' + baseURL + '"' : "undefined"
      };`,
  );
});

//  _    _       _         _    _            _          ______
// | |  | |     | |       | |  | |          | |        |___  /
// | |  | | __ _| |_   _  | |__| | __ _  ___| | _____     / / ___  _ __   ___
// | |  | |/ _` | | | | | |  __  |/ _` |/ __| |/ / __|   / / / _ \| '_ \ / _ \
// | |__| | (_| | | |_| | | |  | | (_| | (__|   <\__ \  / /_| (_) | | | |  __/
// \____/ \__, |_|\__, | |_|  |_|\__,_|\___|_|\_\___/ /_____\___/|_| |_|\___|
//         __/ |   __/ |
//        |___/   |___/

interface Schema {
  type?: string;
  properties?: { [key: string]: any };
  required?: string[];
  nullable?: boolean;
  additionalProperties?: any;
  items?: any;
  enum?: any[];
  anyOf?: Schema[];
  oneOf?: Schema[];
  allOf?: Schema[];
  $ref?: string;
}

interface MergedSchema extends Schema {
  type: string;
  properties: { [key: string]: any };
  required: string[];
  nullable: boolean;
}

async function generateTypes(spec: any) {
  try {
    if (!spec.components || !spec.components.schemas) {
      return;
    }

    const schemas = spec.components.schemas;
    const entries = [];

    for (const [schemaName, schema] of Object.entries(schemas)) {
      const typeDefinition = generateTypeDefinition(
        schemaName,
        schema as Schema,
        spec,
      );
      entries.push(typeDefinition);
    }

    let output = entries.join("\n") + ";";
    output = output.replace(
      /export type (\w+)/g,
      (_match, typeName) => `export type ${typeName.replace(/\s+/g, "_")}`,
    );
    // Fix recursive references
    output = output.replace(/components\["schemas"\]\["([^"]+)"\]/g, "$1");
    // Fix types with spaces in their names
    output = output.replace(/Authifier Error/g, "Authifier_Error");
    output = output.replace(/ISO8601 Timestamp/g, "ISO8601_Timestamp");

    await Deno.writeTextFile("out/types.ts", notice + output);
  } catch (error) {
    console.error("Error processing spec:", error);
  }
}

function generateTypeDefinition(
  schemaName: string,
  schema: Schema,
  spec: any,
): string {
  if (schema.anyOf || schema.oneOf) {
    if (schema.properties || schema.additionalProperties !== undefined) {
      // There are root properties to define globally :()
      const rootPropertiesSchema: Schema = {
        type: "object",
        properties: schema.properties,
        required: schema.required,
        additionalProperties: schema.additionalProperties,
        nullable: schema.nullable,
      };

      // Generate base type for common properties
      const baseType = formatSchema(rootPropertiesSchema, spec);

      // Generate union of all variants
      const variants = (schema.anyOf || schema.oneOf)!.map(
        (subSchema: Schema) => {
          return formatSchema(subSchema, spec);
        },
      );

      const unionType = variants.join(" | ");
      // Combine base type with all variants using an intersection
      return `export type ${schemaName} = ${baseType} & (${unionType});`;
    } else {
      // No root properties, yay
      const types = (schema.anyOf || schema.oneOf)!.map((subSchema: Schema) =>
        formatSchema(subSchema, spec)
      );
      const unionType = types.join(" | ");
      return `export type ${schemaName} = ${unionType};`;
    }
  } else if (schema.allOf) {
    // Handle `allOf` constructs by generating an intersection
    const types = schema.allOf.map((subSchema: Schema) =>
      formatSchema(subSchema, spec)
    );
    const tsType = types.join(" & ");
    return `export type ${schemaName} = ${tsType};`;
  } else if (
    schema.type === "object" ||
    schema.properties ||
    schema.additionalProperties !== undefined
  ) {
    const tsType = formatSchema(schema, spec);
    return `export type ${schemaName} = ${tsType};`;
  } else if (schema.$ref) {
    const refKey = schema.$ref.split("/").pop();
    return `export type ${schemaName} = ${refKey};`;
  } else {
    const tsType = formatSchema(schema, spec);
    return `export type ${schemaName} = ${tsType};`;
  }
}

function formatSchema(schema: Schema, spec: any): string {
  if (schema.$ref) {
    const refKey = schema.$ref.split("/").pop();
    return refKey!;
  } else if (schema.anyOf || schema.oneOf) {
    const types = (schema.anyOf || schema.oneOf)!.map((subSchema: Schema) =>
      formatSchema(subSchema, spec)
    );
    let tsType = types.join(" | ");
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (schema.allOf) {
    // Generate an intersection type
    const types = schema.allOf.map((subSchema: Schema) =>
      formatSchema(subSchema, spec)
    );
    let tsType = types.join(" & ");
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (
    schema.type === "object" ||
    schema.properties ||
    schema.additionalProperties !== undefined
  ) {
    const properties = formatObjectProperties(schema, spec);
    let tsType = `{\n${properties}\n}`;
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (schema.type === "array") {
    const itemType = schema.items
      ? formatSchema(schema.items, spec)
      : "unknown";
    let tsType = `${itemType}[]`;
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (schema.enum) {
    const enumValues = schema.enum.map((value: any) => JSON.stringify(value))
      .join(" | ");
    let tsType = enumValues;
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else if (schema.type) {
    let tsType = mapPrimitiveType(schema.type);
    if (schema.nullable) {
      tsType += " | null";
    }
    return tsType;
  } else {
    return "unknown";
  }
}

function formatObjectProperties(schema: Schema, spec: any): string {
  const requiredProperties = schema.required || [];
  const properties: string[] = [];

  if (schema.properties) {
    properties.push(
      ...Object.entries(schema.properties).map(([key, prop]) => {
        const isRequired = requiredProperties.includes(key);
        return formatProperty(key, prop, isRequired, spec);
      }),
    );
  }

  if (schema.additionalProperties !== undefined) {
    const valueType = formatSchema(schema.additionalProperties, spec);
    properties.push(`  [key: string]: ${valueType};`);
  }

  return properties.join("\n");
}

function formatProperty(
  key: string,
  prop: any,
  isRequired: boolean,
  spec: any,
): string {
  const optionalMark = isRequired ? "" : "?";
  const tsType = formatSchema(prop, spec);
  return `  ${key}${optionalMark}: ${tsType};`;
}

function mapPrimitiveType(type: string): string {
  switch (type) {
    case "string":
      return "string";
    case "number":
    case "integer":
      return "number";
    case "boolean":
      return "boolean";
    case "null":
      return "null";
    case "object":
      return "{ [key: string]: unknown }";
    default:
      return "unknown";
  }
}